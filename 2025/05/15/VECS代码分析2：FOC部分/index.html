<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>夏远的个人主页——VECS代码分析2: FOC部分 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="shortcut icon" href="/imgs/xiayuan_icon.ico" type="image/x-icon">
  <link rel="stylesheet" href="/css/public.css" />
  <link rel="stylesheet" href="/css/layout.css" />
  <link rel="stylesheet" href="/css/iconfont.css" />
  <link rel="stylesheet" href="/css/APlayer.min.css" />
  <script src="/js/APlayer.min.js"></script>
  <script src="/js/jquery.min.js"></script>
  <script src="/js/jquery.pjax.min.js"></script>

  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <script>
    document.title = `夏远的个人主页——VECS代码分析2: FOC部分`
  </script>
<meta name="generator" content="Hexo 7.3.0"></head>

<style>
  .load {
    width: 100%;
    height: 100vh;
    background-color: rgb(37, 35, 40);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    position: relative;
    z-index: 9999;
  }
  .load-circle {
    width: 80px;
    height: 80px;
    border: 8px solid orange;
    border-bottom-color: transparent;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    animation: rotate 1s linear infinite;
    filter: drop-shadow(0 0 3px orange);
  }
  .load-circle-inner {
    width: 40px;
    height: 40px;
    border: 8px solid orange;
    border-top-color: transparent;
    border-radius: 50%;
    animation: rotate-reverse .5s linear infinite;
  }
  .load-text {
    margin-top: 20px;
    font-size: 24px;
    color: orange;
    display: flex;
  }
  .load-text span {
    margin: 0 5px;
    text-shadow: 5px 5px 5px orange;
    animation: move 1s linear infinite;
  }
  .load-text span:nth-child(1) {
    animation-delay: -0.6s;
  }
  .load-text span:nth-child(2) {
    animation-delay: -0.5s;
  }
  .load-text span:nth-child(3) {
    animation-delay: -0.4s;
  }
  .load-text span:nth-child(4) {
    animation-delay: -0.3s;
  }
  .load-text span:nth-child(5) {
    animation-delay: -0.2s;
  }
  .load-text span:nth-child(6) {
    animation-delay: -0.1s;
  }
  @keyframes rotate {
    0% { transform: rotate(0); }
    100% { transform: rotate(360deg); }
  }
  @keyframes rotate-reverse {
    0% { transform: rotate(0); }
    100% { transform: rotate(-360deg); }
  }
  @keyframes move {
    0% { transform: translateY(0%) rotate(0) scale(1); }
    20% { transform: translateY(20%) rotate(10deg) scale(1.2); }
    80% { transform: translateY(-10%) rotate(-20deg) scale(.8);}
    100% { transform: translateY(0) rotate(0) scale(1); }
  }

  .progress {
    position: fixed;
    left: 0; top: 0;
    width: 0;
    height: 3px;
    background-color: green;
    transition: all cubic-bezier(0.215, 0.610, 0.355, 1) .1s;
    z-index: 9999;
  }

  .to-up {
    animation: toUp .5s 1;
  }
  .gray {
    position: fixed;
    left: 0;
    top: 0;
    width: 100%;
    height: 100vh;
    z-index: 9999;
    display: none;
    pointer-events: none;
    background-color: #000;
    mix-blend-mode: color;
  }
  @keyframes toUp {
    from { transform: translateY(15px); opacity: 0; }
    to { transform: translateY(0) ; opacity: 1; }
  }
</style>
<body>
  <div id="load" class="load">
    <div class="load-circle">
      <div class="load-circle-inner"></div>
    </div>
    <p class="load-text">
      <span>L</span>
      <span>O</span>
      <span>A</span>
      <span>D</span>
      <span>I</span>
      <span>N</span>
      <span>G</span>
    </p>
  </div>
  <div id="container" class="container w-100 vh-100" style="display: none;">
    <header class="header">
  <div class="header-wrapper">
    <div class="header-left">
      <div class="header-search">
        <input id="search-input" type="text" class="header-search--input" placeholder="请输入要检索的文章标题" />
        <span id="search-btn" class="header-search--icon"><i class="iconfont icon-sousuo"></i></span>
      </div>
      <div id="search-layer" class="header-search--layer hidden">
        <p class="title">
          <span>以下是搜索内容：</span>
          <span id="close-layer-btn">关闭</span>
        </p>
        <ul>
        </ul>
      </div>
    </div>
    <div class="header-right">
      <ul class="header-menu">
        <li>
          <a href="http://example.com/">
            <i class="header-menu--icon iconfont icon-shouye"></i>
            <span class="header-menu--span">首页</span>
          </a>
        </li>
        <li>
          <a href="http://example.com/log">
            <i class="header-menu--icon iconfont icon-rizhi"></i>
            <span class="header-menu--span">日志</span>
          </a>
        </li>
        <li>
          <a href="http://example.com/link">
            <i class="header-menu--icon iconfont icon-youqinglianjie"></i>
            <span class="header-menu--span">友情链接</span>
          </a>
        </li>
        <li>
          <a href="http://example.com/about">
            <i class="header-menu--icon iconfont icon-guanyuwomen"></i>
            <span class="header-menu--span">关于我</span>
          </a>
        </li>
      </ul>
    </div>
  </div>
</header>

<script>
  const ipt = document.querySelector('#search-input')
  const btn = document.querySelector('#search-btn')
  const layer = document.querySelector('#search-layer')
  const posts = JSON.parse(`[{"title":"10.10.2024凌晨 熬夜看比赛之反思","path":"2024/10/10/10-10-2024凌晨-熬夜看比赛之反思/"},{"title":"10.14.2024 总结","path":"2024/10/15/10-14-2024-总结/"},{"title":"10.15.2024 总结 10.16.2024要做的事","path":"2024/10/16/10-15-2024-总结-10-16-2024要做的事/"},{"title":"10.15.2024学到的东西 & 关于 人生堆栈 项目落地的急迫性","path":"2024/10/16/10-15-2024学到的东西-关于-人生堆栈-项目落地的急迫性/"},{"title":"10.16.2024学到的东西，第二天要做的事情","path":"2024/10/17/10-16-2024学到的东西，第二天要做的事情/"},{"title":"10.16.2024总结","path":"2024/10/17/10-16-2024总结/"},{"title":"10.178.2024学到的东西和今天要做的事情","path":"2024/10/18/10-17-2024学到的东西和今天要做的事情/"},{"title":"10.17.2024总结","path":"2024/10/18/10-17-2024总结/"},{"title":"10.18.2024学到的东西 & 今天要做的事","path":"2024/10/19/10-18-2024学到的东西-今天要做的事/"},{"title":"10.18.2024总结","path":"2024/10/19/10-18-2024总结/"},{"title":"10.19.2024学到的东西 & 今天要做的事情","path":"2024/10/20/10-19-2024学到的东西-今天要做的事情/"},{"title":"10.20.2024总结","path":"2024/10/21/10-20-2024总结/"},{"title":"10.19.2024总结","path":"2024/10/20/10-19-2024总结/"},{"title":"10.20.2024学到的东西 & 今天要做的事情","path":"2024/10/21/10-20-2024学到的东西-今天要做的事情/"},{"title":"10.21.2024学到的东西 & 今天要做的事情","path":"2024/10/22/10-21-2024学到的东西-今天要做的事情/"},{"title":"10.21.2024总结","path":"2024/10/22/10-21-2024总结/"},{"title":"10.25.2024 研究大数据课设时学到的关于回归问题的一些知识","cover":"/images/covers/pythonMeme1.png","path":"2024/10/26/10-25-2024-研究大数据课设时学到的关于回归问题的一些知识/"},{"title":"10.8.2024 总结","path":"2024/10/08/10-8-2024-总结/"},{"title":"10.8.2024 早上上了传感器的课程","path":"2024/10/08/10-8-2024-早上上了传感器的课程/"},{"title":"2025.3~2025.9 学习清单","cover":"/images/covers/2025.3 学习计划.jpg","path":"2025/03/18/2025-3-2025-9-学习清单/"},{"title":"AS5047磁编码器使用心得，SPI模式与ABI模式之争","path":"2025/05/28/AS5047磁编码器使用心得，SPI模式与ABI模式之争/"},{"title":"Bode图1","cover":"/images/covers/bode225.png","path":"2025/03/26/Bode图1/"},{"title":"Bode图2  手绘bode图","cover":"/images/covers/bode225.png","path":"2025/03/26/Bode图2 手绘bode图/"},{"title":"FOC与SVPWM学习1","cover":"/images/covers/foc1.png","path":"2025/03/16/FOC与SVPWM学习1/"},{"title":"FOC与SVPWM学习4","cover":"/images/covers/foc43.png","path":"2025/03/19/FOC与SVPWM学习4/"},{"title":"FOC与SVPWM学习2","cover":"/images/covers/foc2_cover.png","path":"2025/03/17/FOC与SVPWM学习2/"},{"title":"FOC与SVPWM学习3","cover":"/images/covers/just_a_motor.png","path":"2025/03/18/FOC与SVPWM学习3/"},{"title":"FOC学习之SVPWM","cover":"/images/covers/SVPWM2.png","path":"2025/05/07/FOC学习之SVPWM/"},{"title":"PID, 结合根轨迹调参","cover":"/images/covers/pid_cover.png","path":"2025/04/17/PID-结合根轨迹调参/"},{"title":"Nyquist稳定准则","cover":"/images/covers/nygif3.gif","path":"2025/04/17/Nyquist稳定准则/"},{"title":"PID控位置环，两环和三环的区别","path":"2025/05/26/PID控位置环，两环和三环的区别/"},{"title":"Routh-Hurwitz Criterion 劳斯判据","cover":"/images/covers/rh_criterion_cover.png","path":"2025/03/29/Routh-Hurwitz-Criterion-劳斯判据/"},{"title":"VESC代码分析1：固件文件总览","cover":"/images/covers/VESC.png","path":"2025/05/14/VESC代码分析1：固件文件总览/"},{"title":"VECS代码分析2: FOC部分","cover":"/images/covers/VESC.png","path":"2025/05/15/VECS代码分析2：FOC部分/"},{"title":"Hello World","path":"2024/09/29/hello-world/"},{"title":"hexo之还是想把博客的tag搞起来 10.16.2024晚","cover":"/images/covers/neko_confusing.gif","path":"2024/10/16/hexo之还是想把博客的tag搞起来-10-16-2024晚/"},{"title":"VESC学习之FOC有感整定代码","cover":"/images/covers/VESC_ENC_DETECT10.png","path":"2025/05/11/VESC学习之FOC有感整定代码/"},{"title":"hexo博客中插入图片测试","cover":"/images/covers/neko_confusing.gif","path":"2024/10/08/hexo博客中插入图片测试/"},{"title":"hexo博客建设之为每个post单独设置封面的尝试","cover":"/images/covers/neko_confusing.gif","path":"2024/10/22/hexo博客建设之为每个post单独设置封面的尝试/"},{"title":"hexo博客建设之修复空白页 & 第一次尝试添加一个index.html","cover":"/images/covers/neko_confusing.gif","path":"2024/10/19/hexo博客建设之修复空白页-第一次尝试添加一个index-html/"},{"title":"hexo博客建设之开启新的页面","cover":"/images/covers/neko_confusing.gif","path":"2024/10/22/hexo博客建设之开启新的页面/"},{"title":"hexo基本命令","cover":"/images/covers/neko_confusing.gif","path":"2024/09/29/hexo基本命令/"},{"title":"hexo插入图片测试之二","cover":"/images/covers/neko_confusing.gif","path":"2024/10/08/hexo插入图片测试之二/"},{"title":"hexo更改主题，以及修改主题的实践","cover":"/images/covers/neko_confusing.gif","path":"2024/10/11/hexo更改主题，以及修改主题的实践/"},{"title":"关于电机线缆长度对控制效果的影响","cover":"/images/covers/just_a_motor.png","path":"2025/04/17/关于电机线缆长度对控制效果的影响/"},{"title":"夏远的第一篇博客","path":"2024/09/29/夏远的第一篇博客/"},{"title":"国庆的挣扎","path":"2024/10/07/国庆的挣扎/"},{"title":"对傅里叶变换和级数的全新理解","cover":"/images/covers/ft8.png","path":"2025/03/21/对傅里叶变换和级数的全新理解/"},{"title":"敏感度, 敏感度函数, 调整敏感度","cover":"/images/covers/sens4.png","path":"2025/05/28/敏感度, 敏感度函数, 调整敏感度/"},{"title":"我急需审视自己的一些东西","path":"2024/10/14/我急需审视自己的一些东西/"},{"title":"整理桌面，顺便换一张壁纸","path":"2024/10/11/整理桌面，顺便换一张壁纸/"},{"title":"根轨迹介绍与手绘根轨迹","cover":"/images/covers/rl213.png","path":"2025/04/07/根轨迹介绍与手绘根轨迹/"},{"title":"根轨迹补充","cover":"/images/covers/rls18.png","path":"2025/04/17/根轨迹补充/"},{"title":"滞后补偿器设计","cover":"/images/covers/llcd45.png","path":"2025/05/28/滞后补偿器设计/"},{"title":"系统稳定性 闭环系统的稳定性","cover":"/images/covers/syssta1.png","path":"2025/03/29/系统稳定性-闭环系统的稳定性/"},{"title":"终值定理和稳态误差","cover":"/images/covers/fv5.png","path":"2025/03/29/终值定理和稳态误差/"},{"title":"超前补偿器设计","cover":"/images/covers/llcd24.png","path":"2025/05/28/超前补偿器设计/"},{"title":"超前滤波器, 滞后滤波器, 补偿器","cover":"/images/covers/llc_intro_cover.png","path":"2025/05/28/超前滤波器, 滞后滤波器, 补偿器/"},{"title":"过去两天的总结，以及今天的计划","path":"2024/10/14/过去两天的总结，以及今天的计划/"},{"title":"迟到的10.10.2024总结","path":"2024/10/11/迟到的10-10-2024总结/"},{"title":"闭环系统的稳定裕度","cover":"/images/covers/stamar2.png","path":"2025/04/17/闭环系统的稳定裕度/"}]`)
  ipt.addEventListener('keyup', e => {
    if (e.key === 'Enter') {
      handleSearch()
    }
  })
  btn.addEventListener('click', () => {
    handleSearch()
  })

  document.querySelector('#close-layer-btn').addEventListener('click', () => {
    layer.classList.toggle('hidden')
  })

  function handleSearch() {
    if (ipt.value.trim() === '') {
      return
    }
    let html = ''
    const targetPosts = posts.filter(post => post.title.includes(ipt.value))
    targetPosts.forEach(post => {
      html += `
        <li>
          <div>
            <a href="/${post.path}">${post.title.replace(new RegExp(ipt.value), `<span>${ipt.value}</span>`)}</a>
          </div>
          <img src="${post.cover || '/imgs/default-cover.webp' }" />
        </li>
      `
    })
    if (html.trim () === '') {
      html += '<p class="empty">没有搜索到内容</p>'
    }
    layer.querySelector('ul').innerHTML = html
    layer.classList.remove('hidden')
  }
</script> 
    <section id="main" class="main">
      <div class="main-left-wrapper">
<div class="main-left">
  <div class="main-left--block">
    <div class="main-left--info">
      <img src="/imgs/avatar.jpg"" class="main-left--avatar" />
      <div class="main-left--intro">
        <p class="main-left--name">xiayuan</p>
        <div class="main-left--tags">
          <span class="main-left--tag">阴暗</span>
          <span class="main-left--tag">爬行</span>
        </div>
      </div>
    </div>
  
    <div>
      <div class="main-left--motto">
        <p>“今日比昨日更善良”</p>
        <p>“明日比今日更繁忙”</p>
      </div>
      <div class="main-left--github">
        <span class="line"></span>
        <a target="_blank" rel="noopener" href="https://github.com/xtzhyhydwl"><i class="logo iconfont icon-github-fill"></i></a>
        <span class="line"></span>
      </div>
      <div class="main-left--statics">
        <a href="/categories">
          <div>
            <span>0</span>
            <span>分类</span>
          </div>
        </a>
        <a href="/tags">
          <div>
            <span>7</span>
            <span>标签</span>
          </div>
        </a>
        <a href="/archives">
          <div>
            <span>5 </span>
            <span>归档</span>
          </div>
        </a>
      </div>
    </div>
  </div>

  <div class="main-left--block">
    <ul class="main-left--menu">
      
        <li>
          <a href="/">
            <span class="header-menu--span">小站首页</span>
            <i class="header-menu--icon iconfont icon-shouye"></i>
          </a>
        </li>
      
        <li>
          <a href="/log">
            <span class="header-menu--span">个人日志</span>
            <i class="header-menu--icon iconfont icon-rizhi"></i>
          </a>
        </li>
      
        <li>
          <a href="/link">
            <span class="header-menu--span">友情链接</span>
            <i class="header-menu--icon iconfont icon-youqinglianjie"></i>
          </a>
        </li>
      
        <li>
          <a href="/about">
            <span class="header-menu--span">关于自己</span>
            <i class="header-menu--icon iconfont icon-guanyuwomen"></i>
          </a>
        </li>
      
        <li>
          <a href="/tools">
            <span class="header-menu--span">我的工具</span>
            <i class="header-menu--icon iconfont icon-gongju"></i>
          </a>
        </li>
      
    </ul>
  </div>

  <div class="main-left--block">
    <div class="main-left--site">
      <h5 class="main-left--title">
        <span>站点信息</span>
        <i class="iconfont icon-zhandian"></i>
      </h5>
      <p class="main-left--subtitle">
        <span>文章数目：</span>
        <span>61 篇</span>
      </p>
      <p class="main-left--subtitle">
        <span>最近动态：</span>
        <span>今天</span>
      </p>
      <p class="main-left--subtitle">
        <span>上线时间：</span>
        <span>242天</span>
      </p>
      <p class="main-left--subtitle">
        <span>当前版本：</span>
        <span>v1.0.0</span>
      </p>
    </div>
  </div>
</div></div>
      <div id="main-container" class="main-container">


  <link rel="stylesheet" href="/css/partial/article.css" />

<div class="article-container">
  <div class="article">
    <h1 class="article-title">VECS代码分析2: FOC部分</h1>
    <div class="article-info">
      <div class="article-info--item">
        <div class="article-info--info">
          
          <div class="article-info--categories">
            <span>分类：</span>
            
          </div>
          
          
          <div class="article-info--tags">
            <span>标签：</span>
            <a class="tag-link" href="/tags/FOC/" rel="tag">FOC</a><a class="tag-link" href="/tags/VESC/" rel="tag">VESC</a><a class="tag-link" href="/tags/%E5%AD%A6%E4%B9%A0/" rel="tag">学习</a>
          </div>
          
          <p class="article-info--date">日期：2025-05-15 10:51:36</p>
        </div>
        <img src="/images/covers/VESC.png" alt="" class="article-cover">
      </div>
    </div>
    <article class="article-content markdown-body">
      <h3 id="本文将包含的内容"><a href="#本文将包含的内容" class="headerlink" title="本文将包含的内容:"></a>本文将包含的内容:</h3><ol>
<li>VESC的FOC代码分析, <em>从初始化到一个控制周期结束</em></li>
<li>VESC的FOC算法抽象, 对比其与TI白皮书上的FOC算法差异(鸽了, 或者我本来就是顺着白皮书的思路去理解FOC流程的)</li>
</ol>
<h3 id="从代码看VESC的FOC"><a href="#从代码看VESC的FOC" class="headerlink" title="从代码看VESC的FOC"></a>从代码看VESC的FOC</h3><hr>
<h4 id="FOC初始化"><a href="#FOC初始化" class="headerlink" title="FOC初始化"></a>FOC初始化</h4><ul>
<li>入口函数, <code>mcpwm_foc_init</code>, 刚开始先<em>将系统锁定</em>, 组织任何其它线程切换和中断打乱初始化进程. 然后就开始ADC, DMA, TIM的初始化.<br><img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC249.png"></li>
</ul>
<h5 id="DMA和ADC初始化"><a href="#DMA和ADC初始化" class="headerlink" title="DMA和ADC初始化"></a>DMA和ADC初始化</h5><ul>
<li>这两个的初始化连在一起, 直接在<code>foc_init</code>中执行</li>
</ul>
<ol>
<li>使能DMA2和ADC1, 2, 3的外设时钟, 给DMA2 stream 4 分配优先级(5)和<em>dma传输完成后的处理函数(<code>mcpwm_foc_adc_int_handler</code>), 这个处理函数十分重要, 主要的FOC计算在里面完成</em>.<br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC244.png"></li>
<li>初始化DMA2 stream4, 主要关注<em>peripheral to memory的地址(<code>(uint32_t)&amp;ADC_Value</code>)</em>. 并且设置DMA中断为<em>半传输完成触发</em>的模式.<br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC243.png"><br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC242.png"><br> 设置为半传输完成的前提是FOC计算中最重要的几个参数排在前面优先传输. VESC进行FOC控制时最重要的是三相采样电流, 这个是排在最前面传输的, 所以可以使用HT.<br> 优点是<em>不必等待全部传输完成就可以处理数据, 数据实时性提高</em>.<br> 中断执行的函数就是之前提到的<code>mcpwm_foc_adc_int_handler</code>.</li>
<li>初始化三个采样的ADC, 这里使用了<em>ADC三重模式</em>, 一个ADC(ADC1)作为<em>主ADC</em>, 接收外部信号来触发采样, 剩下两个ADC(ADC2, 3)设置为<em>从ADC</em>, <em>接收ADC1的触发信号</em>, 和ADC1同时采样.<br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC241.png"><br> 这种配置的好处是<em>保证了三个ADC永远同时开启采样</em>.<br> 注意到<em>主ADC外部触发是TIM2的CC2中断</em>, 在后文中会作为重要的信号, 暗示<em>ADC采样和PWM生成有严格时序关系</em>.</li>
</ol>
<ul>
<li>DMA和ADC初始化完成.</li>
</ul>
<h5 id="TIM初始化"><a href="#TIM初始化" class="headerlink" title="TIM初始化"></a>TIM初始化</h5><ul>
<li>TIM初始化之初先关掉各个TIM. 这里使用到的TIM有3个, 分别是TIM1, TIM2, TIM8. 以下是TIM的资源调用说明:<br>  比较重要的是<em>TIM1, 产生PWM信号</em>; 和<em>TIM2, 触发采样和FOC计算</em>.<br>  <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC250.png"></li>
<li>tim初始化的入口函数在DMA和AMC初始化好后执行, 函数名是<code>timer_reinit</code><br>  <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC248.png"><br>  传入一个参数是<em>零矢量频率</em>, 具体说是SVPWM中零矢量出现的频率. 关于各种频率, 之后会有说明.</li>
<li>以下是初始化步骤</li>
</ul>
<ol>
<li><p>先用同一个句柄初始化TIM1和TIM8, 它们两个输出的是同样性质的PWM, 其中TIM1就是用来输出我们FOC控制用的PWM波形的. 而TIM8是留给潜在的双电机控制.<br> 注意到<em>计数模式是中心对齐模式</em>(<code>TIM_CounterMode_CenterAligned1</code>), 即向上计数到顶, 触发一次中断, 然后向下计数到0, 触发一次中断. 这样就<em>生成了一个中心对称的波形</em>, 中间是1逻辑, 两边是0逻辑. 我们使用这种模式来输出SVPWM需要的对称波形. 在一个完整的SVPWM波形中, <em>触发两次中断(中间一次末尾一次)</em>, 周期长度是一般PWM波周期的两倍.<br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC247.png"><br> 如下图, SVPWM需要的波形是中心对称的.<br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC235.png"><br> 还有一些别的设置, 没什么特别的<br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC246.png"></p>
</li>
<li><p>TIM2的初始化, 初始化为output compare, PWM1, 三路PWM输出, <em>实际上并不输出PWM来控制电机, 而是作为一个工具定时器, 通过捕获TIM1生成PWM完成的事件来产生中断, 进而驱动ADC采样和DMA传输, 进而触发中断运行FOC计算函数.</em><br> 下图为TIM2的Base设置和OC模式设置.<br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC245.png"><br> 下图为与TIM2有关的<em>触发和中断</em>配置:<br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC234.png"></p>
</li>
</ol>
<ul>
<li>用上图理清<em>PWM输出与采样的触发关系和时序</em>:</li>
</ul>
<ol start="2">
<li>TIM2中断输出的是<code>TIM_IT_CC2</code>, 触发条件是TIM2向上计数到CCR2. </li>
<li><em><code>TIM_IT_CC2</code>能够触发ADC采样</em>.</li>
<li>TIM1的<code>TIM_TRGOSource_Update</code>事件的触发条件是一个PWM波产生完毕.</li>
<li><em>TIM1的<code>TIM_TRGOSource_Update</code>事件能够重置TIM2的计数值.</em></li>
<li>CCR2实际设置为<em>很小的数值</em>, 所以一旦*<code>TIM_TRGOSource_Update</code>事件送达*, TIM2重置为0, 然后瞬间计数到CCR2, <em>瞬间触发中断<code>TIM_IT_CC2</code>, 驱动采样, 以及后续的FOC计算.</em></li>
<li>所以PWM生成完毕和采样是紧接着执行的.</li>
</ol>
<h5 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h5><ol>
<li>初始化检查输入电压, 上电后一部分等待时间来源于此.<br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC240.png"></li>
<li>处理故障码 FAULT_CODE<br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC239.png"></li>
<li>设置某种偏置电流, 以及<em>进行偏置电流检测</em>. 电调连接电机上电的时候, 电机会发出微弱的电流嗡嗡声, 也许就是在通电测试这个offset<br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC238.png"></li>
<li>开启三个线程, 分别是FOC辅助定时器, hfi相关计算, pid相关计算. 相关内容我们在其它文章中会讲到.<del>(又挖坑)</del><br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC237.png"></li>
<li>绑定画图指令, 在终端可以用foc_tmp命令和foc_plot_hfi_en在上位机画图<br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC236.png"></li>
</ol>
<ul>
<li>到此, FOC的初始化结束</li>
</ul>
<hr>
<h4 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h4><h5 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h5><ul>
<li><em>采样的过程由ADC和DMA自动完成, 数据处理部分的代码主要在<code>mcpwm_foc_adc_int_handler</code>中.</em></li>
<li><code>mcpwm_foc_adc_int_handler</code>函数在DMA传输完成一半之后触发执行, DMA传输在ADC转换完成后执行, 而ADC采样的触发条件是TIM1的PWM输出完成, 所以<em>函数执行频率是pwm周期频率.(但是并非FOC计算频率)</em></li>
<li>如前所述, 一个SVPWM波形由两段中心对称的PWM组成, <em>第一段PWM完成后会触发采样</em>, 但是SVPWM只走完一半, 在一般的应用下此时并不适合FOC计算(HFI和基于硬件的高频控制模式另说). 此时<code>mcpwm_foc_adc_int_handler</code>函数会<em>检查电压矢量是否处于v7</em>, 即是否在SVPWM中间段, 来决定是否<em>跳过这次FOC计算</em>. </li>
<li>关于<em>各种频率</em>, 统一作如下说明: <ol>
<li><code>f_zv</code>, 零矢量频率, 即<em>v0和v7出现的频率</em>, 是PWM频率, VESC中可设置.</li>
<li>SVPWM频率, 是<em>PWM频率的一半</em>, 因为一对PWM波组成一个SVPWM波.</li>
<li><em>采样频率, 等于PWM频率, 等于f_zv</em>.</li>
<li>控制器频率, 等于SVPWM频率, 因为每次PWM产生都触发采样, 但是计算在v7时<em>轮空一次</em>, <em>等同于一半PWM频率</em>, 也就是SVPWM频率.</li>
</ol>
<ul>
<li>补充一点: 三相PWM时是v0-&gt;v7-&gt;v0-&gt;v7交替出现, 搞不懂这一点的去看我写的<em>SVPWM</em>的讲解.</li>
</ul>
</li>
<li>由此引出<em>整个FOC流程</em>:<ol>
<li>前半波形生成完成-&gt;</li>
<li>ADC采样-&gt;DMA传输-&gt;</li>
<li>传输中断函数中进行FOC计算-&gt;检测到是v7, 不进行FOC计算-&gt;</li>
<li>后半波形生成完毕-&gt;</li>
<li>ADC采样-&gt;DMA传输-&gt;</li>
<li>传输中断函数中进行FOC计算-&gt;检测到是v0, 进行FOC计算和SVPWM计算, 应用占空比-&gt;</li>
<li>按照新占空比生成新波形-&gt; </li>
<li>前半波形生成完成…</li>
</ol>
<ul>
<li>这个流程会在接下来逐渐解释清楚.</li>
</ul>
</li>
</ul>
<h5 id="代码-mcpwm-foc-adc-int-handler"><a href="#代码-mcpwm-foc-adc-int-handler" class="headerlink" title="代码(mcpwm_foc_adc_int_handler)"></a>代码(<code>mcpwm_foc_adc_int_handler</code>)</h5><ul>
<li>从上到下是执行顺序.</li>
</ul>
<ol>
<li>检查减采样, 可以用宏定义设置跳过一些采样; <em>判断是不是处在v7向量, 如果是, 接下来跳过本次FOC计算.</em><br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC233.png"></li>
<li>判断一系列特殊情况下的采样, 直接在里面进行foc计算然后退出, 不是本次的重点<br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC232.png"><br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC231.png"></li>
<li>用宏定义从DMA传输的目标地址中<em>获取采样电流</em><br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC230.png"><br> 并且应用初始化的时候算好的<em>offset</em><br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC229.png"></li>
<li>根据<em>采样模式</em>, 对采到的电流值进行<em>修正</em>, 有三种策略:<ul>
<li>High Current是用两个小电流计算大电流, <em>能够突破硬件限制, 采样到更大的电流</em><br>  <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC228.png"></li>
<li>Longest Zero Time是用低占空比的两相的电流来估计高占空比的一相的电流, <em>VESC默认是这个模式</em>.<br>  <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC227.png"></li>
<li>All Sensors Combined是<em>三个全用</em>, 此时不存在估计某一相的值, 直接用采样值计算i_α, i_β了<br>  <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC251.png"></li>
</ul>
</li>
<li>修正后, <em>将ADC值转换为电流值, 这样就计算出三相电流ia, ib, ic</em><br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC226.png"></li>
</ol>
<ul>
<li>至此采样部分结束, 进入FOC计算部分.</li>
</ul>
<hr>
<h4 id="FOC计算"><a href="#FOC计算" class="headerlink" title="FOC计算"></a>FOC计算</h4><h5 id="前置知识-FOC计算是要算什么"><a href="#前置知识-FOC计算是要算什么" class="headerlink" title="前置知识: FOC计算是要算什么?"></a>前置知识: FOC计算是要算什么?</h5><ul>
<li>完整的FOC流程图如下, 更多内容详见我的 <em>FOC与SVPWM学习</em> 部分<br>  <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC225.png"><br>  接下来按照1234的顺序, 讲代码是如何执行FOC计算的, 由于有些步骤穿插在一起, 不保证执行顺序的严格, 但是可以保证这些代码是在极短的时间内被统一执行的.</li>
<li>FOC计算分两大种情况, 电调主动驱动和不主动驱动的情况, 由于后者相比前者代码简单得多, 且会跳过一部分前者的步骤, 所以接下来默认的情况是电调主动驱动.</li>
</ul>
<h5 id="1-当前相位计算-mcpwm-foc-adc-int-handler"><a href="#1-当前相位计算-mcpwm-foc-adc-int-handler" class="headerlink" title="1 当前相位计算(mcpwm_foc_adc_int_handler)"></a>1 当前相位计算(<code>mcpwm_foc_adc_int_handler</code>)</h5><ol>
<li>判断是否处于手动覆写相位模式, 即手动改变电角度, 使电调输出定向的磁场. 这种模式一般只在整定过程中会用到.<br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC224.png"></li>
<li><em>根据<code>foc_sensor_mode</code>来选择相位的来源</em>. 需要注意的是即使选择了有感模式, 无感的<em>观测器</em>仍然一直更新, 并且会<em>对外部编码器的数值进行补偿和修正</em>.<ul>
<li>使用编码器的模式:<br>  <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC223.png"></li>
<li>使用霍尔传感器, 也有observer进行修正的环节<br>  <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC222.png"></li>
<li><em>无感, 使用observer作为相位来源</em>, 有时会进行补偿<br>  <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC220.png"></li>
<li>HFI也有一套获取相位的规则, 不展开讲了</li>
</ul>
</li>
<li><em>单独判断一些特殊情况</em>, 例如刹车, 开环等, 开环就不需要得知相位了<br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC219.png"></li>
</ol>
<ul>
<li>到此我们<em>得到了电机的相位, 也就是电角度</em>.</li>
</ul>
<h5 id="2-当前id-iq计算-目标id-iq计算-mcpwm-foc-adc-int-handler-control-current"><a href="#2-当前id-iq计算-目标id-iq计算-mcpwm-foc-adc-int-handler-control-current" class="headerlink" title="2 当前id iq计算, 目标id iq计算(mcpwm_foc_adc_int_handler, control_current)"></a>2 当前id iq计算, 目标id iq计算(<code>mcpwm_foc_adc_int_handler</code>, <code>control_current</code>)</h5><ul>
<li>我们需要<em>将当前id iq与目标id iq作比较, 产生一个差作为输入, 这样才能进行闭环控制.</em></li>
</ul>
<ol>
<li>先说目标电流, 这个简单. 目标有两个来源, 一个是直接控制电流到某个值I, 那么通常就设置id为0, iq为I; 另一个是<em>用PID计算出的电流</em>(速度控制, 位置控制). PID和接口函数的说明不在本文的计划中, 所以我们只要知道有其它线程在跑PID函数, 有时会<em>在外部改变目标值, 每次计算我们只要读取进来就好了.</em><br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC218.png"></li>
<li>进行当前id iq的计算, 需要先将采样得到的三相电流, <em>通过clark变换到αβ系</em>, 即i_α, i_β, 这一步其实在计算相位前就执行了<br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC217.png"></li>
<li>得到当前i_α, i_β后, 再<em>通过park变换, 变换到dq坐标系</em>, 即可得到当前id iq, 这一步在函数<code>control_current</code>中进行(<code>control_current</code>被<code>mcpwm_foc_adc_int_handler</code>调用)<br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC216.png"><br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC215.png"></li>
<li><em>产生误差</em>, 输入电流控制器<br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC214.png"></li>
</ol>
<h5 id="3-电流控制器-control-current"><a href="#3-电流控制器-control-current" class="headerlink" title="3 电流控制器(control_current)"></a>3 电流控制器(<code>control_current</code>)</h5><ul>
<li><code>control_current</code>函数几乎就是一整个<em>PI控制器+SVPWM</em>, 所谓PI控制器是电流控制器的核心, 其功能是<em>根据iq id的error计算应该输出的vd, vq, 既包含闭环控制的参数计算, 又实现了从电流到电压的转换</em>, 这种转换基于对电机的建模, 需要先测量电机的参数: 电阻R, 电感L, 磁通ψ等.</li>
<li>关于PI部分, 我自己琢磨了一段时间, 总算是有一些门道, 以下是我在学习代码过程中写的注释, 以及PI控制器代码部分:<br>  <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC213.png"><br>  <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC210.png"></li>
<li>通过以下几点设问来总结我的理解：<ol>
<li><em>PI控制器的作用</em>是什么？输入输出是什么？<br> PI控制器将设定电流与真实电流之间的差值转化为要设定的电压. <em>输入是Iq_err, Id_err, 输出是vq_set, vd_set.</em></li>
<li>为什么最终要转化成电压?<br> 因为<em>三相逆变器只能直接控制三相电压</em>.</li>
<li>我们都知道电压 &#x3D; 电流*电阻 + 电感*电流变化率, 想要多少电流不是可以直接用这个公式反推出电压电流关系吗? <em>为什么还需要PI控制器</em>呢?<ol>
<li><em>电机是一个动态的和复杂的系统</em>, 以上公式只适用于<em>电机静止不动</em>的情况, 一旦电机开始旋转, 就要考虑反电动势和耦合项(之后会讲)对电流的影响, 即存在不确定的干扰项. <em>对于变化的目标电流, 系统需要有持续追踪的能力, 所以需要引入一个PI控制器进行自动控制.</em></li>
<li>加入PI控制器进行闭环控制, 不仅能够使系统有一定的追踪输入的能力(系统从type 0变为type 1), 还能<em>通过调整ki和kd使系统满足各种性能指标, 例如响应速度, 稳态误差</em>等. (结合<em>根轨迹法</em>思考)</li>
</ol>
</li>
<li>为什么只使用PI控制器, <em>而不是PID控制器</em>?<br> 电机作为一个开环系统, 本质是一个<em>一阶惯性系统</em>: tf &#x3D; 1&#x2F;(Ls+R), 不像二阶系统有振荡和超调的问题. D环节, 也就是微分环节, <em>主要用于改善二阶以上系统的超调和响应速度问题, 用在一阶惯性系统上, 没有实际效果, 反而可能放大噪声</em>. PI控制器中P环节决定响应速度, I环节消除稳态误差, 已经能够满足性能需求.</li>
<li>如何调整PI控制器的kp和ki?<br> VESC中, <em>kp的计算与L成正比, ki的计算与成正比</em>, 因为:<ol>
<li>电感L越大, 电流上升越慢, 需要更大的kp来提高系统的响应速度.</li>
<li>电阻R越大, 需要更大的ki来补偿电阻带来的稳态误差.</li>
</ol>
</li>
</ol>
</li>
<li>转换过程中, vd vq是存在<em>耦合</em>的, 换句话说, vd不是单纯只受id影响, vq不是单纯只受iq影响, 而是<em>存在交叉项</em>, 如下图公式所示<br>  <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC212.png"><br>  其中ωe是电机电转速, ψm是磁通.<br>  对vd和vq进行<em>交叉项的补偿</em>, 能够减少耦合的影响, 举例来说, <em>单独调整vq, 不会对vd影响太大</em>.<br>  对vq进行<em>反电动势补偿</em>, 在高速运行的情况下控制效果会更好, 因为<em>PI控制器不用对抗这种随速度增大的扰动</em>.<br>  注意到补偿项的计算<em>使用了预测的速度</em>(当前周期的瞬时速度估计), 而不是已有的速度数据((上周期相位-本周期相位)&#x2F;dt, 本质上是上个周期的平均速度), 所以<em>这是一种前馈补偿, 让未来才能得知的数据作用于当下</em>.<br>  <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC211.png"></li>
<li>补偿之后, 我们就得到了目标vd和vq.</li>
</ul>
<h5 id="4-SVPWM计算-control-current"><a href="#4-SVPWM计算-control-current" class="headerlink" title="4 SVPWM计算(control_current)"></a>4 SVPWM计算(control_current)</h5><ul>
<li>接下来最后一步, 是<em>通过park逆变换将目标vd, vq转换为目标v_alpha, v_beta, 然后进行SVPWM计算, 算出具体的目标三相占空比.</em></li>
</ul>
<ol>
<li>将vq, vd进行归一化, 然后计算出归一化的v_alpha, v_beta. <em>归一化的目的是在后续计算占空比时, 不用再进行归一化</em>.<br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC29.png"><br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC28.png"></li>
<li>进行<em>死区时间补偿</em>(<code>update_valpha_vbeta</code>)<ul>
<li>死区时间 deadzone time 是由于mos管在开启和关断时都需要一定的时间, 为了防止上下管同时导通, 需要加入死区时间的保护, <em>实际输出的电压波形可能并不是设计的电压</em>.<br>  <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC27.png"><br>  死区时间补偿是<em>通过略微调整实际输出电压, 使最终合成的电压矢量满足理想状态下的要求</em>. 补偿前后的效果比较如下<br>  <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC26.png"><br>  代码, 相关原理以后再深究.<br>  <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC25.png"></li>
</ul>
</li>
<li>进行SVPWM计算(foc_svm)<ul>
<li>关于SVPWM的详细介绍, 在之前的文章中有, 完全不懂SVPWM的建议先去看看.</li>
<li>通过PI控制器和死区时间补偿之后, 我们得到了归一化的目标v_alpha和v_beta, 现在可以进行SVPWM的计算, 然后更新占空比了<br>  <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC24.png"></li>
</ul>
<ol>
<li>SVPWM计算的第一步, 是<em>用v_alpha和v_beta确定电压矢量所在的扇区</em><br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC23.png"></li>
<li>然后根据所在扇区不同, 逆变器的三个桥有不同的开关顺序, <em>按照顺序计算各相通电时间</em><br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC22.png"></li>
<li>返回各项时间, <em>时间的衡量方法是计数值</em>, 例如最大计数值是100, 那么某一相40%占空比意味着40%的通电时间, 输出计数值就是40.</li>
<li>通过修改TIM1-&gt;CCRx的值, 应用占空比, <em>下次PWM生成, 就会按照这个占空比</em>.<br> <img src="/2025/05/15/VECS%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%902%EF%BC%9AFOC%E9%83%A8%E5%88%86/VESC21.png"></li>
</ol>
</li>
</ol>
<hr>
<h4 id="流程总结"><a href="#流程总结" class="headerlink" title="流程总结"></a>流程总结</h4><ul>
<li>如前所述, 完整FOC流程为:<ol>
<li>前半波形生成完成-&gt;</li>
<li>ADC采样-&gt;DMA传输-&gt;</li>
<li>传输中断函数中进行FOC计算-&gt;检测到是v7, 不进行FOC计算-&gt;</li>
<li>后半波形生成完毕-&gt;</li>
<li>ADC采样-&gt;DMA传输-&gt;</li>
<li>传输中断函数中进行FOC计算-&gt;检测到是v0, 进行FOC计算和SVPWM计算, 应用占空比-&gt;</li>
<li>按照新占空比生成新波形-&gt; </li>
<li>前半波形生成完成…<br>  可以再回头去对照着看一下.</li>
</ol>
</li>
</ul>

    </article>
    
  </div>
  <div class="article-catelogue">
    <div class="article-catelogue--wrapper">
      <div class="catelogue catelogue-1">
        <h3>目录</h3>
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E6%96%87%E5%B0%86%E5%8C%85%E5%90%AB%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">1.</span> <span class="toc-text">本文将包含的内容:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E4%BB%A3%E7%A0%81%E7%9C%8BVESC%E7%9A%84FOC"><span class="toc-number">2.</span> <span class="toc-text">从代码看VESC的FOC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FOC%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.1.</span> <span class="toc-text">FOC初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#DMA%E5%92%8CADC%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.1.1.</span> <span class="toc-text">DMA和ADC初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TIM%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.1.2.</span> <span class="toc-text">TIM初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E5%AE%83"><span class="toc-number">2.1.3.</span> <span class="toc-text">其它</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%87%E6%A0%B7"><span class="toc-number">2.2.</span> <span class="toc-text">采样</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">2.2.1.</span> <span class="toc-text">前置知识</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-mcpwm-foc-adc-int-handler"><span class="toc-number">2.2.2.</span> <span class="toc-text">代码(mcpwm_foc_adc_int_handler)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FOC%E8%AE%A1%E7%AE%97"><span class="toc-number">2.3.</span> <span class="toc-text">FOC计算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-FOC%E8%AE%A1%E7%AE%97%E6%98%AF%E8%A6%81%E7%AE%97%E4%BB%80%E4%B9%88"><span class="toc-number">2.3.1.</span> <span class="toc-text">前置知识: FOC计算是要算什么?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%BD%93%E5%89%8D%E7%9B%B8%E4%BD%8D%E8%AE%A1%E7%AE%97-mcpwm-foc-adc-int-handler"><span class="toc-number">2.3.2.</span> <span class="toc-text">1 当前相位计算(mcpwm_foc_adc_int_handler)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%BD%93%E5%89%8Did-iq%E8%AE%A1%E7%AE%97-%E7%9B%AE%E6%A0%87id-iq%E8%AE%A1%E7%AE%97-mcpwm-foc-adc-int-handler-control-current"><span class="toc-number">2.3.3.</span> <span class="toc-text">2 当前id iq计算, 目标id iq计算(mcpwm_foc_adc_int_handler, control_current)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E7%94%B5%E6%B5%81%E6%8E%A7%E5%88%B6%E5%99%A8-control-current"><span class="toc-number">2.3.4.</span> <span class="toc-text">3 电流控制器(control_current)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-SVPWM%E8%AE%A1%E7%AE%97-control-current"><span class="toc-number">2.3.5.</span> <span class="toc-text">4 SVPWM计算(control_current)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="toc-number">2.4.</span> <span class="toc-text">流程总结</span></a></li></ol></li></ol>
      </div>
      
        <div class="catelogue catelogue-2">
          
            <p>
              <span>上一篇：</span>
              <a href="/2025/05/26/PID控位置环，两环和三环的区别/">PID控位置环，两环和三环的区别</a>
            </p>
           
          
            <p>
              <span>下一篇</span>
              <a href="/2025/05/14/VESC代码分析1：固件文件总览/">VESC代码分析1：固件文件总览</a>
            </p>
          
        </div>
      
    </div>
  </div>
</div>



<script>
  $(document).on('pjax:complete', function() {
    const tocs = document.querySelector('.toc')
    const links = tocs ? tocs.querySelectorAll('a') : []
    links.forEach(link => {
      link.addEventListener('click', e => {
        const href = decodeURIComponent(e.href)
        href.search(/#(.*)/)
        const id = RegExp.$1
        const target = document.querySelector('#' + id)
        const top = target.offsetTop
        document.documentElement.scrollTo({
          top: top - 100,
          behavior: 'smooth'
        })
        e.preventDefault()
      })
    })
  })
</script> 

</div>
      <div class="main-right-wrapper"><div class="main-right">
  <div class="main-right--board">
    <div class="main-right--title">
      <h5>公告栏</h5>
      <i class="iconfont icon-gonggao"></i>
    </div>
    <div class="main-right--content">
      电兵一个 
    </div>
  </div>

  <div id="aplayer" class="main-right--music"></div>

  <div class="operate-items">
    <div class="operate-item backtop">
      <i class="iconfont icon-huidaodingbu"></i>
      <span>回到顶部</span>
    </div>
    
  </div>

  <div class="main-right--site">
    <div class="main-right--power">
      <p>Power By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/docs/">Hexo</a>.</p>
      <p>Theme：<a target="_blank" rel="noopener" href="https://github.com/Aizener/hexo-theme-cola">Cola.</a></p>
    </div>
    <p class="main-right--refer"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/#/Integrated/index">蜀ICP备2022005384号-1</a> </p>
  </div>
</div>

<script>
  function setOperateItem () {
    const reg = /\d{4}\/\d{2}\/\d{2}\/.+/
    const path = location.pathname
    const operateDom = document.querySelector('.main-right .operate-items')
    const commentDom = document.querySelector('.turn-comment')
    const cateloguDom = document.querySelector('.article-catelogue > .article-catelogue--wrapper');

    if (commentDom) {
      if (reg.test(path) || path.match(/\/log\/.+/)) {
        commentDom.classList.remove('hidden')
        const newDom = operateDom.cloneNode(true);
        const _backtopDom = newDom.querySelector('.backtop');
        const _commentDom = newDom.querySelector('.turn-comment');
        _backtopDom.addEventListener('click', () => backTopEvent());
        _commentDom.addEventListener('click', () => commentDomEvent());
        cateloguDom.appendChild(newDom);
      } else {
        commentDom.classList.add('hidden')
      }
    }
  }

  setOperateItem()
  const musics = JSON.parse(`[{"name":"サンダルリープ","artist":"Orangestar,IA","url":"music/サンダルリープ.mp3","cover":"/imgs/SEASIDE%20SOLILOQUIES.jpg"},{"name":"apple flavoured feeling of friendship","artist":"Corn Wave","url":"music/Corn Wave - apple flavoured feeling of friendship.flac","cover":"/imgs%20/elephant%20entertainment.jpg"},{"name":"You're Not The Only One I Know","artist":"The Sundays","url":"music/You're Not The Only One I Know.flac","cover":"https://img.discogs.com/NvfJb9ygLElF3ORDHTy1ZFtMnKE=/fit-in/600x600/filters:strip_icc():format(jpeg):mode_rgb():quality(90)/discogs-images/R-1573808-1316777764.jpeg.jpg"}]`)
  const ap = new APlayer({
    container: document.querySelector('#aplayer'),
    audio: musics,
  })

  $(document).on('pjax:complete', function() {
    setOperateItem()
  })

  document.querySelector('.backtop').addEventListener('click', () => {
    backTopEvent();
  })
  const dom = document.querySelector('.turn-comment')
  dom && dom.addEventListener('click', () => {
    commentDomEvent();
  })

  function backTopEvent() {
    document.documentElement.scrollTo({
      top: 0,
      behavior: 'smooth'
    })
  }

  function commentDomEvent() {
    const commentDom = document.querySelector('.comments-intro')
    if (!commentDom) return
    const top = commentDom.offsetTop, height = commentDom.offsetHeight
    document.documentElement.scrollTo({
      top: top - 2 * height,
      behavior: 'smooth'
    })
  }
</script></div>
    </section>
  </div>
  <div id="progress" class="progress"></div>
  <div id="gray" class="gray"></div>

  <script>
    function initScroll () {
      document.addEventListener('scroll', () => {
        const doc = document.documentElement
        const scrollTop = doc.scrollTop
        const pageHeight = doc.offsetHeight
        const clientHeight = doc.clientHeight
        const ratio = scrollTop / (pageHeight - clientHeight)
        const progress = document.querySelector('#progress')
        const avatarImg = document.querySelector('.main-left--avatar')
        progress.style.width = (100 * ratio) + '%'
        avatarImg.style.transform = `rotate(${360 * ratio}deg)`
      })
    }

    const rootPath = "/"

    const checkAndSetArticlePageLayout = () => {
      const path = location.pathname.replace(rootPath, '');
      if (
        /^\/?\d{4}\/\d{2}\/\d{2}\/.*/.test(path) ||
        /^log\/.+/.test(path)
      ) {
        $('.main-container, .main-right, .main-right-wrapper').addClass('is-article')
      } else {
        $('.main-container, .main-right, .main-right-wrapper').removeClass('is-article')
      }
    }

    const gray = "none"
    const setGrayStyle = () => {
      if (gray === 'none') {
        return
      } else if (gray === 'index') {
        location.pathname === '/' ? $('#gray').show() : $('#gray').hide()
      } else if (gray === 'all') {
        $('#gray').show()
      }
    }
    setGrayStyle()


    window.onload = function () {
      checkAndSetArticlePageLayout()
      setTimeout(() => {
        $('#load').slideUp()
        $('#container').slideToggle()
        setTimeout(() => {
          initScroll();
        }, 500)
      }, 500)
    }
    
    let status = 0
    // 对所有链接跳转事件绑定pjax容器container
    $(document).pjax('a[target!=_blank]', '#main-container', {
      container: '#main-container',
      fragment: '#main-container',
      timeout: 8000
    })

    $(document).on('pjax:start', function() {
    })
    $(document).on('pjax:complete', function() {
      status = 0
      $('.main-container').addClass('to-up').on('animationend', function() {
        $(this).removeClass('to-up')
      })
      setGrayStyle()
      checkAndSetArticlePageLayout()
    })
    $(document).on('pjax:popstate', function() {
      status = -1
      checkAndSetArticlePageLayout()
    });
  </script>
</body>
</html>